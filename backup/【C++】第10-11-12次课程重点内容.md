
# 1. 掌握双层(多层)循环的意思

C++多层循环的主要知识要点:

- 嵌套结构：多层循环是指在一个循环内部包含另一个循环。
- 执行顺序：外层循环每执行一次，内层循环会完整执行一轮。
- 循环变量：每层循环通常使用不同的循环变量，避免混淆。
- 性能考虑：多层循环可能导致时间复杂度增加，需要谨慎使用。
- 退出控制：可以使用break或return语句从内层循环直接退出外层循环。
- 继续下一次：continue语句只影响当前层循环。
- 初始化位置：注意内层循环变量的初始化位置，避免逻辑错误。

比如：双层for循环的逻辑是这样的：

<img width="255" alt="111" src="https://github.com/mcoblackmore/liuchanghui.github.io/assets/49425642/5d34ba21-42ca-4050-95b8-4d85205f0736">

由于“外层for循环没执行一次，内层for循环全部执行完”（一定要理解哦！）所以上面的双层for循环的执行结果是：
<img width="435" alt="222" src="https://github.com/mcoblackmore/liuchanghui.github.io/assets/49425642/d5e47383-937b-4ac3-81ac-e060786f74b7">

# 2.break和continue的使用要点注意事项

## break 的使用要点:

- 功能: 立即终止当前循环或switch语句。
- 作用范围: 只影响最内层的循环或switch。
- 多层循环中的使用: 如果需要跳出多层循环,可能需要使用标签或布尔标志。
- 常见用途: 在找到特定条件时提前结束循环,避免不必要的迭代。
- 注意事项: 过度使用可能导致代码结构混乱,影响可读性。

```
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break; // 当 i 等于 5 时,立即终止循环
    }
    cout << i << " ";
}
// 输出: 0 1 2 3 4
```

## continue 的使用要点:

- 功能: 跳过当前循环的剩余部分,直接进入下一次迭代。
- 作用范围: 只影响当前层循环。
- 多层循环中的使用: 只会跳过最内层循环的当前迭代。
- 常见用途: 在不满足某些条件时跳过处理,继续下一次迭代。
- 注意事项: 确保continue之后的循环控制变量仍能正确更新。

示例1：
```
for (int i = 0; i < 5; i++) {
    if (i % 2 == 0) {
        continue; // 跳过偶数
    }
    cout << i << " ";
}
// 输出: 1 3
```
示例2：多层循环中使用break:
```
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break; // 只跳出内层循环
        }
        cout << i << j << " ";
    }
    cout << endl;
}
// 输出:
// 00 01 02
// 10
// 20 21 22
```
#  3. 最古老的算法-辗转相除法

辗转相除法,也称为欧几里得算法(Euclidean Algorithm),是一种计算两个数最大公约数(因数)(GCD)的古老而有效的方法。以下是该算法的主要要点: 

> **两个正整数a和b，他们的最大公约数等于a除以b的余数和b之间的最大公约数**

例如：求a=123456和b=7890之间的最大公约数，按照上面辗转相除法的思想：我们可以画出下面的图形：
<img width="442" alt="333" src="https://github.com/mcoblackmore/liuchanghui.github.io/assets/49425642/14b4318d-177a-4292-917a-45d6637cf3d6">

看上图最后一行，当算出a与b的余数为0的时候，那么b就是原来的12345和7890之间的最大公因数

如何用代码来实现上面的算法呢？显然辗转相除就是一个循环的过程：

```
int main(){
	int m,n;
	cin>>m>>n;
	int r;
	int a = m, b=n; 
	while(m%n!=0){
		r = m%n;
		m=n;
		n = r;
	}
	cout<<"最大公因数："<<n<<endl; //跳出循环后的n就是最大公因数：
	cout<<"最小公倍数"<<a*b/n;   //最小公倍数 
}
```

上面的代码我们同时求出了两个数之间的最小公倍数，这里利用了一个公式，大家必须要记住的求最小公倍数的公式：

**如果想求a与b之间的最小公倍数n，那么如果你知道a与b之间的最大公因数是m，那么就有：a X b = m X n；所以，求最小公倍数就是n = (a X b) / m**


刘老师编辑于2024.7.7日下午

