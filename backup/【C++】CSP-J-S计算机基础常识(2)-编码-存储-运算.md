# 1.字符编码 
## 1.1 ASCII 码（最早的字符编码）★★★★
ASCII 码由 7 个二进制位表示，但用一个字节（8 位二进制位）表示，第一位往往取 0。如下图：
‘0’的 ASCII 码：48，十六进制为 30H
‘A’的 ASCII 码：65，十六进制为 41H
‘a’的 ASCII 码，97，十六进制为 61H
<img width="323" alt="asc" src="https://github.com/mcoblackmore/liuchanghui.github.io/assets/49425642/7f17afa1-441c-4398-b96e-e9392cf90460">

## 1.2 汉字编码★★★
通常，我们使用区位码表示汉字的编码。
 区位码：4 位十进制数，前两位表示区码，后两位表示位码。2 个字节。
 国标码：区位码的区码和位码分别用 16 进制表示后，加上 2020H，即为国标码。2 个字节。
 汉字的机内码：国标码+8080H。2 个字节。
## 1.3 UNICODE
 Unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等，实现跨语言、跨平台的文本转换及处理。
 Unicode 通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为 0 就可以。

## 1.4 字形码（字模）

字形码，点阵代码的一种。为了将汉字在显示器或打印机上输出，把汉字按图形符号设计成点阵图，就得到了相应的点阵代码（字形码）。用于显示的字库叫显示字库。显示一个汉字一般采用 16×16 点阵或 24×24 点阵或 48×48 点阵。已知汉字点阵的大小，可以计算出存储一个汉字所需占用的字节空间。

> 图像存储的基础概念：

**像素**是图像中一个不可分割的单位或者元素(可以看做是一个个的小方格)。每个小方格都有一个明确的位置和被分配的色彩数值，所有的小方格的颜色和位置组合起来决定了该图像呈现出来的样子。
**分辨率**是指屏幕上能显示的像素的个数。如 1920x1080 是指水平方向上有 1920 个像素点，垂直方向上有 1080 个像素点。
**图像的位分辨率** 又称为 **位深度**，在记录数字图像的颜色时，计算机实际上是用每个像素需要的位深度来表示的。8 位色,每个像素所能显示的彩色数为 2 的 8 次方,即 256 种颜色。16 位增强色,16 位彩色,每个像素所能显示的彩色数为 2 的 16 次方,即 65536 种颜色。24 位真彩色,每个像素所能显示的彩色数为 24 位,即2 的 24 次方,约1680 万种颜色。

**例 1：**用 16×16 点阵表示一个汉字，就是将每个汉字用 16 行，每行 16 个点表示，一个点需要 1 位二进制代码，16 个点需用 16 位二进制代码（即 2 个字节），共 16 行，所以需要 16 行×(2 字节/行)=32 字节，即 16×16 点阵表示一个汉字，字形码需用 32 字节。

**例 2：**一段时长为 10 秒、1024×800 像素、24 位真彩色、NTSC 制式（30 帧/秒）的未经压缩 AVI 格式无声视频，其文件存储容量计算，若将该视频文件压缩为一个 70MB 的压缩文件，则视频的压缩比为多少。给出的视频为 30 帧/秒，共 10 秒，那么该视频共 300 帧，每帧画面为 1024*800*24，那么该文件的存储容量为 1024∗800∗24∗300
/(8∗1024∗1024)= 703.125𝑀𝐵，若压缩为 70MB，那么压缩比约为 10：1。

#v2 .整数存储 
## 2.1 原码表示法★★
符号位+二进制表示；符号位用 0 表正数 用 1 表负数。
如 8 位系统中，11 的原码为 00001011，-11 的原码为 10001011。
原码表示范围：[-127, +127]
**注意：原码的0不是唯一的！**

## 2.2 反码表示法★★
正数反码等于原码；负数反码符号位不变，其他位取反。
如 8 位系统中，11 的反码为 00001011，-11 的反码为 11110100。
表示范围：[-127, +127]
## 2.3 补码表示法★★
正数补码等于原码；负数补码符号位不变，其他位为反码+1。
如 8 位系统中，11 的补码为 00001011，-11 的补码为 11110101。
计算机用补码存储数据的优点：
 可以将减法操作变为加法操作，更适合 CPU 运算。
 0 具有唯一的表示
 8 位补码可以表示到-128，原码和反码不可以。
表示范围：[-128, +127]

> 计算机为什么用补码进行计算：
> 首先，我们来看几个 4 位二进制数进行运算的例子！
> 在原码下，1-1=1+（-1）=0001+1001=1010=-2
> 我们可以看出，由于符号位参与计算，对于减法来说，用原码表示计算结果并不正确。
> 在反码下，1-1=1+（-1）=0001+1110=1111=-0
> 我们可以看出，用反码表示计算结果问题出现在“0”这个特殊数值上，正常来说，0 不应该带符号，0 带
> 符号没有任何意义。
> 在补码下，1-1=1+（-1）=0001+1111=0000=0
> 我们可以看出，真值没有问题，0 带符号的问题也解决了！
> 综上所述，我们使用补码的原因主要有以下两个方面：
> 第一，我们人脑可以知道原码的第一位是符号位，但是计算机不知道，而恰好补码表示中的符号位可以与数值位一起参加运算，弥补了计算机不能辨别符号位的缺憾。
> 第二，我们人脑可以快速计算减法，但是计算机很难做到，所以我们根据运算法则——减去一个正数等于加上一个负数，将减法运算转换成为加法运算，对计算机而言，这大大地简化了运算的过程。

## 2.4 例子：

| 真值  |原码   | 反码  | 补码  |
|---|---|---|---|
| +127  | 01111111  | 01111111  | 01111111  |
| +39  | 00100111  |  00100111  |  00100111  |
| +0  | 00000000  | 00000000  | 00000000  |
| -0  | 10000000  | 11111111  |  00000000 |
| -39  | 10100111  | 11011000|  11011001|
| -127  | 11111111| 10000000| 10000001|
| -128  | 无法表示| 无法表示| 10000000|

---
**必会练习题**

1.[x]补码=10011000，其原码是（    ）
A.011001111	B.11101000		C.11100110		D.01100101

2.已知x的原码表示为11110111,下列(   )是x的补码表示。
A.01010011B	
B.10001001B	
C.11111111B	
D.11000000B

3.十进制数-103的补码是 （   ）
A.10011001 	B.11100111	     C.10110011	D.00011001

4.关于零的原码反码补码，说法正确的是（   ）
A.零的原码表示只有一种	B.零的反码表示只有一种
C.零的补码表示只有一种    D.零的原码反码补码的表示都是两种 

下列关于十进制数100的正确说法是（       ）
A.原码为01100100B,   
B.反码为64H        
C.反码为9BH
D.补码为64H		
E.补码为9BH



